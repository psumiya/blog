= Beyond Hello World!

link:index.html[Home]

:description: Suggestions on creating a framework for building production-ready systems rapidly
:author: Sumiya
:nofooter:
:sectlinks:

== Premise
In many systems, there is a concept of Inversion of Control. In my experience, I think it is beneficial to also apply the concept to your software delivery process.

== Production-Ready

The https://12factor.net[Twelve-Factor] app describes some production readiness things.

Beyond that, here are some additional useful checkboxes in my opinion.

. Can an engineer on the team deploy the application via a Continuous Integration / Continuous Deployment (CI/CD) workflow?
. Is the infrastructure written as code? Can the infrastructure be deployed via a CI/CD workflow? Is the infrastructure flexible to support the load patterns that this service needs (for example, spiky bursts versus continuous fixed-band traffic)?
. Does the build phase of CI/CD workflow check for test coverage and code quality?
. Do you have the ability to run automated functional and/or performance tests via your CI/CD workflow?
. Are failure modes for the application well-defined? if so, are there alarms and alerts configured for these failure modes? E.g., do you get alerted when your applications p95 drops below a certain level, or if your application notices an increased error rate (e.g., increased HTTP 500 API Response Codes beyond a set threshold)?
. Is the system observable? For example, after deployment, can you ask interesting questions of your system via some tool as to how certain requests behaved the way they did (could be increased latency, unexpected errors, etc.)?
. Is there a playbook available for SREs to look at should something go wrong?
. Has the team shared the service design internally so more than one engineer has at least a passing familiarity with the application?

== OODA - Observe, Orient, Decide, and Act

=== Observe

Observe your existing systems as to how you are making them production-ready.

If you agree with the above premise for production-ready, then it is not a leap to say that all our processes should be optimized to deliver the above in a frictionless manner.

For an organization with disparate teams shipping software, providing templates for each step mentioned above should help increase the shipping speed.

=== Orient

Most mature organizations I have been part of have had some sort of process for delivery to production. As I said in my premise above, it is often better to visualize the process as slightly inverted, where the proverbial `hello world` or your own `pet-clinic` template is written after the production system is laid out.

This approach sets up the team to rapidly iterate on the required features across multiple deployments in a week, sometimes in a day.

This way, when we call a feature done, it really _is_ done.

=== Decide

At this point, you need to decide if it is worth making the investment in having a team build tooling to automate some or all of these processes.

After all, these are repeatable processes. And the more services your organization needs, the more your investment in tooling is going to pay off in the future.

As in other things, watch out for premature optimization. As engineers, it is always tempting for us to solve for N instead of 1, but sometimes your N is < 3, at which point it is okay to duplicate some code, script, or configuration.

=== Act

Once you have decided to invest, you should go forth and engage teams on what are the most common things every team ends up doing on their own, possibly copy-pasting solutions from the past or other teams.

Then, group such tasks and start building out tooling for them one by one.

* Example 1: Say multiple teams are deploying AWS Lambdas to production. You could identify the steps involved in deploying such an app, and provide a Jenkins job/stage, or a GitOps workflow, that can take the source code location, can run automated checks, can execute some company or org-wide compliance (say, some minimum log4j version), and build and deploy the code in a blue-green fashion to the target environment.
* Example 2: Say every API in your organization needs to ensure their p95 response duration is less than 200 milliseconds. You can provide a monitoring script parameterized to accept the p95 duration, teams can take the script and execute against their environment to build alarms that will detect a degradation.

Over a period of time, you will end up with a massive set of legos that different teams can leverage for their deployments.